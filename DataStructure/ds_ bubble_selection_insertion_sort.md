# 📖 Bubble & Selection & Insertion Sort

## 목차

- [1. 🧪 Bubble Sort](#-stack)
  - [1.1 ⛓ Stack 주요 메서드](#-stack-주요-메서드)
  - [1.2 📚 Stack 구현 방법](#-stack-구현-방법)
  - [1.3 🍁 Stack 역할](#-stack-역할)
- [2. 🧪 Queue](#-queue)
   - [2.1 ⛓ Queue 주요 메서드](#-queue-주요-메서드)
   - [2.2 🍁 Queue 역할](#-queue-역할)
- [3. 참조](#-참조)

## 🧪 Bubble Sort

🔹 Bubble Sort는 Selection Sort와 유사한 알고리즘으로 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘 이다. 이름의 유래로는 정렬 과정에서 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어졌다고 한다.

버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다. 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

<br/>

### ⛓ Bubble Sort 예제

---

<div align="center">
    <img src = "./img/ds_ bubble_selection_insertion_sort_1.png" alt="버블정렬 이미지" width="350">
    <img src = "./img/ds_ bubble_selection_insertion_sort_2.gif" alt="버블정렬 이미지" width="650">
</div>

<br/>

- 1회전
    - 첫 번째 자료 7을 두 번째 자료 4와 비교하여 교환하고, 두 번째의 7과 세 번째의 5를 비교하여 교환하고, 세 번째의 7과 네 번째의 1을 비교하여 교환하고, 네 번째의 7과 다섯 번째의 3을 비교하여 교환한다. 이 과정에서 자료를 네 번 비교한다. 그리고 가장 큰 자료가 맨 끝으로 이동하므로 다음 회전에서는 맨 끝에 있는 자료는 비교할 필요가 없다.

- 2회전
    - 첫 번째의 4을 두 번째 5와 비교하여 교환하지 않고, 두 번째의 5와 세 번째의 1을 비교하여 교환하고, 세 번째의 5와 네 번째의 3을 비교하여 교환한다. 이 과정에서 자료를 세 번 비교한다. 비교한 자료 중 가장 큰 자료가 끝에서 두 번째에 놓인다.

- 3회전
    - 첫 번째의 4를 두 번째 1과 비교하여 교환하고, 두 번째의 4와 세 번째의 3을 비교하여 교환한다. 이 과정에서 자료를 두 번 비교한다. 비교한 자료 중 가장 큰 자료가 끝에서 세 번째에 놓인다.

- 4회전
    - 첫 번째의 1과 두 번째의 3을 비교하여 교환하지 않는다.

<br/>

### 📚 Bubble Sort 특징

---

```java
void bubbleSort(int[] arr) {
    int temp = 0;

	for (int i = n-1; i > 0; i--) {
        for (int j = 0; j < i; j++) { 
			if (arr[j] > arr[j + 1]) {
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	System.out.println(Arrays.toString(arr));
}
```

- 장점
    - 구현이 매우 간단하다.
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. => 제자리 정렬(in-place sorting)

- 단점
    - 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
    - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
    - 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.

- 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.

<br/>

### 🍁 Bubble Sort 시간 복잡도

---

시간복잡도를 계산하면, ```(n-1) + (n-2) + (n-3) + .... + 2 + 1 => n(n-1)/2``` 이므로, O(n^2) 이다. 또한, Bubble Sort는 정렬이 돼있던 안돼있던, 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 O(n^2) 으로 동일하다.

<br/>

---

## 🧪 Selection Sort


🔹 


<br/>

### ⛓ Queue 주요 메서드

---



<br/>

### 🍁 Queue 역할

---

🔹 

<br/>

## 📸 참조

https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html <br/>
https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html