# **📌1. 개요**

**자가 균형 이진트리**

일반 이진 트리에서 자식들이 한쪽으로 치우치는 것을 막기 위한 균형 기능이 추가된 트리

**자가 균형 이진트리의 종류**

- AVL트리 : 자식의 depth를 이용
- Red Black Tree : 노드의 색을 이용

| <img src=".\img\ds_red_black_tree_11.png"> | <img src=".\img\ds_red_black_tree_10.png"> |
| ------------------------------------------ | ------------------------------------------ |

당연히 트리를 압축해서 빈틈 없이 꽉꽉 채워 넣으면 탐색 횟수는 당연히 줄어들겠죠?

하지만 현실적으로 저장, 삭제 작업은 트리의 상태를 보며 하는 작업이 아니므로,, 아무 값이든 들어올 수 있고, 어떤 값이든 나갈 수 있어야 합니다.

---

# **📌 2. 정의**

## 🌳 2.1 모든 노드는 red / black 의 색을 갖는다.

아래는 해당 규칙을 어긴 케이스이다.

<img src=".\img\ds_red_black_tree_3.png">

## 🌳 2.2 root 노드는 black이다.

## 🌳 2.3 모든 NIL 노드는 black이다. (null은 black으로 간주)

<img src =".\img\ds_red_black_tree_4.png">

### 💡 왜 필요할까?

RB트리 구현 시 부모의 형제나, 형제의 자식 노드를 확인해야 하는 경우가 있다. 이때 형제에게 자식이 없다던지 하는 예외를 매번 처리하게 되면 구현 양이 많아진다. 모든 색 체크 시 if null > black, else > check color ... ~~귀찮죠?~~

그래서 자녀가 없을 때 자녀를 nil노드로 표기. 우리가 수업 시간에 배운 String 자료형은 기본값이 null 이듯이 비슷한 맥락! null을 의미하는 노드를 만들어두고 그 친구의 색을 black으로 만드는 방법 고안!

새로운 노드를 만들 때도 우선 새로운 노드의 부모 자식을 모두 NIL로 일단 채우고, 연결하는 방식 채택. 값이 있는 노드와 동등하게 취급

RB 트리에서 leaf 노드는 nil 노드

관습적으로 NIL 노드는 그림으로 표현시 생략한다.

## 🌳 2.4 모든 red는 black 자식을 갖는다. (red가 연속적으로 존재할 수 없다.)

아래는 RB트리에서 가능한 모든 경우의 수이다.

<img src =".\img\ds_red_black_tree_1.png">

아래는 올바르지 않은 RB 트리의 예시이다.

<img src =".\img\ds_red_black_tree_2.png">

## 🌳 2.5 임의의 노드에서 자손 nil노드들까지 향하는 모든 경로는 모두 같은 수의 black 노드가 존재한다.(자기 자신은 count 제외)

<img src =".\img\ds_red_black_tree_12.png">

시작 점에서 이동 가능한 모든 경로를 고려했을 때, 만나는 black의 개수를 세보자. 이 때 모두 같은 값을 가져야한다는 성질.

- node 8번의 경우 nil노드로 향하는 모든 경우의 수는 총 5가지. 이때 만나게 되는 black의 개수는 각각 모두 1개
- node 13번은 자손 nil노드로 향하는 총 6가지 경우의 수 모두 black을 1개 만난다.

### 💡 2.5.1 node x의 black height

노드 x에서 임의의 자손 nil 노드까지 내려가는 경로에서 black 수 (자기 자신은 카운트 제외) **2.4** 속성을 만족해야 성립하는 개념

### 💡 2.5.2 색을 바꾸면서도 2.4 속성 유지하기

RB tree가 **2.4** 속성을 만족하고, 두 자녀가 같은 색을 가질 때, 부모와 두 자녀의 색을 바꿔줘도 해당 속성을 여전히 만족한다.
<img src=".\img\ds_red_black_tree_8.png"> | <img src=".\img\ds_red_black_tree_9.png">
---|---|

# **📌3. 삽입 규칙**

- 삽입하는 노드의 색은 항상 red (삽입 후에도 2.5 속성을 만족하기 위해)

## 🌳 3.0 삽입 전 RB 트리 속성 만족한 상태

## 🌳 3.1 삽입 방식은 일반 BST와 동일

## 🌳 3.2 삽입 후 RB 트리 위반 여부 확인

### 💡 3.2.1 root 노드가 red라면 black으로 바꾸기

### 💡 3.2.2 double-red 발생 시 red 하나를 넘기기 위해 BST 특징 또한 유지하면서 넘기는 "회전" 을 사용

<img src=".\img\ds_red_black_tree_13.png">

## 🌳 3.3 RB 트리 속성을 위반했다면 재조정

## 🌳 3.4 RB 트리 속성을 다시 만족

# **📌4. 삽입 예시**

## 🌳 4.1 삽입 후 2.4 속성 위반했을 때 case#3 해결하기

<img src=".\img\ds_red_black_tree_16.png">

### 💡 (case#3) 삽입된 red 노드가 부모의 왼쪽 자녀 && 부모가 red && 부모가 할아버지의 왼쪽 자녀 && 삼촌(=부모의 형제)은 black

#### 부모와 할아버지의 색을 바꾼 후 할아버지 기준으로 오른쪽으로 회전한다.

| <img src=".\img\ds_red_black_tree_14.png"> | <img src=".\img\ds_red_black_tree_15.png"> |
| ------------------------------------------ | ------------------------------------------ |

- insert(10)
- 20과 50의 색을 바꿔준다.
- 50을 기준으로 오른쪽으로 회전
- 2.4를 포함해 모든 속성 만족!

## 🌳 4.2 삽입 후 2.4 속성 위반했을 때 case#2 해결 후 case#3 형태로 만들기

<img src=".\img\ds_red_black_tree_21.png">

### 💡 (case#2) 삽입된 red 노드가 부모의 오른쪽 자녀 &&& 부모가 red && 부모가 할아버지의 왼쪽 자녀 && 삼촌(=부모의 형제)은 black

#### 부모를 기준으로 왼쪽으로 회전한 뒤 case#3의 방식으로 해결

| <img src=".\img\ds_red_black_tree_17.png"> | <img src=".\img\ds_red_black_tree_18.png"> |
| ------------------------------------------ | ------------------------------------------ |

- inser(40)
- 2.4 속성 위반을 해결하기 위해 red를 하나 넘겨야 하는데, BST 특징 또한 유지하면서 넘기려면 회전을 사용해야 한다. 회전을 어떻게 사용할지가 관건!
- case#3와 다른 점은, 삽입된 노드를 기준으로 할아버지까지의 경로가 꺾였다는 점.
- 꺾인 부분을 펴줘서 case3와 같은 형태로 만들면 case3와 같은 방식으로 해결 가능!!
- 20 기준으로 왼쪽으로 회전한다. 회전 후에는 2.4 이외의 속성은 모두 만족. 이제 case#3의 형태가 됐다.

| <img src=".\img\ds_red_black_tree_19.png"> | <img src=".\img\ds_red_black_tree_20.png"> |
| ------------------------------------------ | ------------------------------------------ |

- 40과 50의 색을 바꾼다.
- 50 기준으로 오른쪽으로 회전한다.
- rbtree의 모든 속성 만족!

## 🌳 4.3 삽입 후 2.4 속성 위반했을 때 case#1

<img src=".\img\ds_red_black_tree_25.png">

### 💡 (case#1) 삽입된 red 노드의 부모가 red && 삼촌(=부모의 형제)도 red

#### 부모와 삼촌을 black으로 바꾸고 할아버지를 red로 바꾼 뒤 할아버지에서 다시 확인 시작

| <img src=".\img\ds_red_black_tree_22.png"> | <img src=".\img\ds_red_black_tree_23.png"> | <img src=".\img\ds_red_black_tree_24.png"> |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |

- insert(30)
- red black tree 2.4 속성 위반
- red가 한쪽으로 몰려 있지 않아서 옮길 수가 없다...
- 아까 2.5 속성은 부모와 자녀의 색을 바꿔도 유지된다는 성질을 떠올려보자!
- 2.4(double-red 금지)를 만족시키면서 2.5(자손 nil노드까지 향하며 만나는 black노드 개수는 항상 같다)를 유지하려면, 10과 50을 black으로 바꾸고 20을 red로 바꾸면 된다.
- 20 이 루트노드라서 2.2 속성 (root 노드는 black이어야 한다.) 위반
- 20을 black으로 바꿔주자

## 🌳 4.4 기타 예제 (4.1-4.3 응용)

| <img src=".\img\ds_red_black_tree_26.png"> | <img src=".\img\ds_red_black_tree_27.png"> |
| ------------------------------------------ | ------------------------------------------ |

- insert(40)
- 2.4 속성 위반 (double-red 금지). case#1 상태
- 부모와 삼촌을 black으로, 할아버지는 red로 변경하자.
- 할아버지인 50에서 확인 후 모든 속성을 만족하기 때문에 상황 종료

| <img src=".\img\ds_red_black_tree_28.png"> | <img src=".\img\ds_red_black_tree_29.png"> |
| ------------------------------------------ | ------------------------------------------ |

- insert(35)
- 2.4 속성을 위반한 case#2 상태
- 40을 기준으로 오른쪽으로 회전해서 case#3의 형태로 만들자.
- 2.4 속성을 위반한 case#3 상태

| <img src=".\img\ds_red_black_tree_30.png"> | <img src=".\img\ds_red_black_tree_31.png"> |
| ------------------------------------------ | ------------------------------------------ |

- 30과 35의 색을 바꾸고, 30을 기준으로 왼쪽으로 회전시키자.
- rbtree 속성 모두 만족

| <img src=".\img\ds_red_black_tree_33.png"> | <img src=".\img\ds_red_black_tree_32.png"> |
| ------------------------------------------ | ------------------------------------------ |

- insert(25)
- 2.4 속성을 위반한 case#1 상태
- 부모와 삼촌을 black으로, 할아버지는 red로 변경하자

- 할아버지인 35에서 확인해보니 2.4 속성을 위반한 case#2 상태! 50을 기준으로 오른쪽으로 회전해서 case#3의 형태로 만들자.
- 35를 위로 올리면서 50은 35의 오른쪽 자녀로 내려가게 되고, 그럼 40이 붕뜨게 되는데, 50의 왼쪽 자녀 자리가 비니까 40이 그 자리를 차지하면 됨

| <img src=".\img\ds_red_black_tree_34.png"> | <img src=".\img\ds_red_black_tree_35.png"> | <img src=".\img\ds_red_black_tree_36.png"> |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |

- 2.4 속성을 위반한 case#3 상태이므로 20과 35의 색을 바꾸고, 20을 기준으로 왼쪽으로 회전
- 20은 35의 왼쪽 자녀로 내려가게 되고, 35의 서브트리들이 다같이 위로 올라오는데, 이때 30-25가 붕뜨게 됨. 하지만 20의 오른쪽 자녀 자리가 비어있으니까 그 자리로!

# **📌5. 삭제 규칙**

## 🌳 5.0 삭제 전 RB 트리 속성 만족한 상태

## 🌳 5.1 삭제 방식은 일반 BST와 동일

## 🌳 5.2 삭제 후 RB 트리 속성 위반 여부 확인

### 💡 3.2.1 root 노드가 red라면 black으로 바꾸기

### 💡 3.2.2 double-red 발생 시 red 하나를 넘기기 위해 BST 특징 또한

## 🌳 5.3 RB 트리 속성을 위반했다면 재조정

## 🌳 5.4 RB 트리 속성을 다시 만족

# **📌6. 삭제 예시**

RB 트리에서 노드를 삭제할 때 어떤 색이 삭제되는 지가 속성 위반 여부를 확인할 때 매우 중요

<img src=".\img\ds_red_black_tree_37.png">

## 🌳 6.1 실제 삭제되는 노드의 색 판단 방법

### 💡 삭제하려는 노드이 자녀가 없거나 하나라면 삭제 되는 색 = 삭제되는 노드의 색

- 25 삭제 -> red 삭제
- 80 삭제 -> black 삭제
- 40 삭제 -> black 삭제

### 💡 삭제하려는 노드의 자녀가 둘이라면 삭제되는 색 = 삭제되는 노드의 sucessor의 색

- 20 삭제 -> succesor 25 -> red 삭제
- 35 삭제 -> successor 37 -> red 삭제
- 50 삭제 -> successor 80 -> black 삭제

## 🌳 6.2 속성 위반 여부 확인

### 💡 삭제되는 색이 red라면 어떠한 속성도 위반하지 않는다.

### 💡 삭제되는 색이 black 이라면 2.2, 2.4, 2.5 속성을 위반할 수 있다.

| <img src=".\img\ds_red_black_tree_38.png"> | <img src=".\img\ds_red_black_tree_39.png"> |
| ------------------------------------------ | ------------------------------------------ |

## 🌳 6.3 삭제되는 색이 black일 때 2.2 위반 해결하기

### 💡 루트 노드를 black으로 바꾼다.

삭제되는 색이 black일 때, 특수한 상황을 제외하면 2.5 속성을 항상 위반하게 된다.

### 💡 삭제되는 색이 black이고 2.5 위반일 때 **extra black** 부여

- 경로에서 black 수를 카운트 할 때 extrea black은 하나의 black으로 카운트 된다.
- extra black을 부여받은 노드는 doubly black이 되거나, red-and-black이 된다.

| <img src=".\img\ds_red_black_tree_40.png"> | <img src=".\img\ds_red_black_tree_41.png"> | <img src=".\img\ds_red_black_tree_42.png"> |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |

- 10 삭제
- 어디에 extra black을 부여해야하나? 삭제된 색의 위치를 대체한 노드!
- 삭제된 색은 10의 black이므로 10의 위치를 대체한 노드인 nil 노드에 extra black을 부여
- 2.5 속성 다시 만족
- **doubly black**: extra black이 부여된 black 노드

| <img src=".\img\ds_red_black_tree_43.png"> | <img src=".\img\ds_red_black_tree_44.png"> | <img src=".\img\ds_red_black_tree_45.png"> |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |

- 30 삭제
- 30은 자녀가 하나라서 삭제되는 색은 30의 black
- 2.5 속성 위반이므로 extra black 부여
- 삭제된 색은 30의 black이었으므로 30의 위치를 대체한 노드인 25에 extra black 부여
- 2.5 속성 다시 만족
- **red-and-black** : extra black이 부여된 red 노드

### 💡 결론: extra black을 부여받은 노드는 doubly black이 되거나, red-and-black 이 된다.

## 🌳 6.4 extra black 부여 후 red-and-black 해결하기

### 💡 red-and-black을 black으로 바꾸면 해결

| <img src=".\img\ds_red_black_tree_46.png"> | <img src=".\img\ds_red_black_tree_47.png"> | <img src=".\img\ds_red_black_tree_48.png"> |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |

- 30 삭제
- 30은 자녀가 하나라서 삭제되는 색은 30의 black -> 2.5 위반
- 20과 25가 바로 연결되면서 2.4 위반
- 30을 대체하는 25의 red에 extra black 부여
- 25는 red-and-black이 됐으니 25를 black으로 바꿔주면 종료
- 2.4와 2.5를 위반한 것을 동시에 해결.

## 🌳 6.4 extra black 부여 후 doubly black 해결하기

### 💡 extra black을 부여했더니 double black이 생겼다면 결국 extra black을 어떻게 없앨 것인지가 관건

doubly black의 형제의 색과, 그 형제의 자녀들의 색을 기준으로 4가지 케이스로 분리 (15:00-26:00 대체)

### 💡 6.4.1 doubly black의 오른쪽 형제가 black && 그 형제의 오른쪽 자녀가 red일 때

#### 오른쪽 형제는 부모의 색으로, 오른쪽 형제의 오른쪽 자녀는 black으로, 부모는 black으로 바꾼 후에 부모를 기준으로 왼쪽으로 회전하면 해결

<img src=".\img\ds_red_black_tree_50.png">

### 💡 6.4.2 doubly black의 오른쪽 형제가 black && 그 형제의 왼쪽 자녀가 red && 그 형제의 오른쪽 자녀는 black일 때

#### doubly black의 형제의 오른쪽 자녀가 red가 되게 만들어서 6.4.1 적용해 해결

#### E 위치에 red가 오도록 만들기 위해 C와 D의 색을 바꾼 후에 D를 기준으로 오른쪽으로 회전하면 된다.

#### C는 B의 색으로 B와 D는 black으로 바꾼 후 B를 기준으로 왼쪽으로 회전하면 해결

| <img src=".\img\ds_red_black_tree_52.png"> | <img src=".\img\ds_red_black_tree_53.png"> | <img src=".\img\ds_red_black_tree_54.png"> |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |

### 💡 6.4.3 doubly black의 형제가 black && 그 형제의 두 자녀 모두 black일 때

doubly black과 그 형제의 black을 모아서 부모에게 전달해서 부모가 extra black을 해결하도록 위임한다.

#### B가 red-and-black이 됐다면 black으로 바꿔주면 상황 종료

#### B가 doubly black이 됐다면 B가 루트 노드라면 black으로 바꿔서 해결, 아닐 경우 다른 케이스로 해결

| <img src=".\img\ds_red_black_tree_55.png"> | <img src=".\img\ds_red_black_tree_56.png"> |
| ------------------------------------------ | ------------------------------------------ |

### 💡 6.4.4 doubly black의 오른쪽 형제가 red 일때

부모와 형제의 색을 바꾸고 부모를 기준으로 왼쪽으로 회전한 뒤 doubly black을 기준으로 나머지 케이스 중 하나로 해결

| <img src=".\img\ds_red_black_tree_57.png"> | <img src=".\img\ds_red_black_tree_58.png"> |
| ------------------------------------------ | ------------------------------------------ |

## 🌳 6.5 Red-Black Tree vs AVL Tree

| <img src=".\img\ds_red_black_tree_49.png"> | <img src=".\img\ds_red_black_tree_50.png"> |
| ------------------------------------------ | ------------------------------------------ |

# **📌7. 면접 빈출**

## 🌳 7.1 RB Tree란 무엇인가요?

- RB tree는 데이터를 저장하거나 검색하기 위한 자료구조로, 이진 검색 트리입니다.
  루트에서 리프까지의 경로에 나타나는 노드의 색깔을 제한함으로써, 트리의 균형을 근사적으로 유지합니다.

- BST의 삽입, 삭제 연산과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조입니다.

- node 구조체의 parent, color, key 멤버들의 값을 확인하며 규칙을 지킴으로써 양쪽의 균형을 맞추게 됩니다. 회전하는 것도 연산이 들어가기 때문에 완전한 균형 알고리즘은 아닙니다.

## 🌳 7.2 RB Tree의 작동 원리는 어떻게 되나요?

- RB 트리는 다음 다섯 가지 속성을 만족해야합니다.

모든 노드는 빨간색, 검은색 둘 중 하나이다.
루트 노드는 검은색이다.
모든 리프(NIL)은 검은색이다.
노드가 빨간색이면 그 노드의 자식은 모두 검은색이다. 
각 노드로부터 그 노드의 자손인 리프로 가는 경로들은 모두 같은 수의 흑색 노드를 포함한다.

## 🌳 7.3 RB Tree의 삽입 알고리즘은 어떻게 구현되나요?

BST(Binary Sear Tree: 이진 탐색 트리)의 특성을 유지하면서 노드를 삽입합니다.
삽입된 노드를 빨간색으로 지정합니다. (Black-height를 최소화하기 위해서)
RBT의 특성을 위배했을 경우, 노드의 색깔을 조정합니다.
Black-Height가 위배되었을 경우, rotation을 통해 height를 조정합니다.

## 🌳 7.4 RB Tree의 삭제 알고리즘은 어떻게 구현되나요?

BST의 특성을 유지하면서 노드를 삭제합니다.
삭제될 노드의 child의 개수에 따라 rotation 방법이 달라집니다.

## 🌳 7.5 RB Tree의 시간 복잡도는 어떻게 되나요?

- 탐색, 입력, 삭제에 O(logN)의 시간이 걸립니다.

## 🌳 7.6 다른 이진 탐색 트리 알고리즘들과 비교했을 때, 어떤 장점이 있나요?

- Worst Case에서도 O(logN)의 탐색 시간으로 탐색하기 위해서는 자가 균형 이진 트리가 필요합니다. 자가 균형 이진 트리의 종류는 대표적으로 레드블랙 트리, AVL 트리가 있습니다.
  - AVL 트리는 레드블랙 트리보다 더 엄격하게 균형이 잡혀있기 때문에, 삽입과 삭제를 할 때 최악의 경우 더 많은 회전(rotation)을 필요로 합니다. 레드 블랙 트리는 실 사용에 효율적이고, 최악의 경우에도 우수한 실행 시간을 보입니다.  n개의 노드가 있을 때 O(logN)의 시간복잡도로 삽입, 삭제, 검색을 할 수 있는 장점이 있습니다.

## 🌳 7.7 RB Tree가 사용되는 예시는 어떤 것이 있나요?

### 💡 7.7.1 Java Collection API의 Map Interface 구현체인 HashMap의 Seperate Chaining 구현에서 사용한다.

: Key 값의 Collision이 발생할 경우 같은 Hash 값을 가지는 원소들을 Collection으로 관리하는데, 이 때 원소의 개수가 많아지면 RB Tree를 이용해서 관리하여 연산 시간을 O(logn)으로 관리한다.

⇒ 데이터의 개수가 일정 이상일 때에는 링크드 리스트 대신 트리를 사용하는 것이 성능상 이점이 있다.
⇒ 링크드 리스트를 사용할 것인가 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 키-값 쌍의 개수이다.
즉, 하나의 해시 버킷에 8개의 키-값 쌍이 모이면 링크드 리스트를 트리로 변경한다. 만약 해당 버킷에 있는 데이터를 삭제하여 개수가 6개에 이르면 다시 링크드 리스트로 변경한다. 트리는 링크드 리스트보다 메모리 사용량이 많고, 데이터의 개수가 적을 때 트리와 링크드 리스트의 Worst Case 수행시간 차이 비교가 의미가 없기 때문이다.

### 💡 7.7.2 RB Tree는 Radix Tree와 더불어 Linux Kernel에서 가장 많이 사용하는 Tree 자료구조 입니다.

: 기존 Tree 자료구조의 단점은 최악의 경우 노드가 Linked-List의 형태로 저장되어 탐색 시간 복잡도가 O(N)이 된다는 점이다. RB Tree는 노드의 삽입과 삭제가 이루어질 때, Tree가 조건에 맞게 스스로 균형을 이루기 때문에 O(logN)의 시간복잡도를 보장한다.

### 💡 7.7.3 Linux의 기본 스케줄러인 CFS 스케줄링 알고리즘에서 사용합니다.

: 테스크의 소요 시간 기준으로 프로세스를 관리하기 위해 RB Tree를 이용해서 스케줄링을 관리한다.

## 🌳 7.8 RB Tree를 사용할 때 주의해야 할 점은 무엇인가?

- RB Tree는 동적으로 메모리를 할당하고 해제해야하는 자료구조입니다.
  따라서 RB Tree를 사용할 때는 메모리 누수가 발생하지 않게 하기 위해 메모리 할당/해제를 올바르게 해야합니다.

---

출처 : https://dev-game-standalone.tistory.com/92, https://youtu.be/2MdsebfJOyM?si=PgO6FSy5IAHDNpd5, https://bo5mi.tistory.com/212
