## 목차

- [1. 🎤 네트워크의 기초](#-네트워크의-기초)
- [2. 🎤 대역폭](#-대역폭)
- [3. 🎤 OSI 7계층](#-osi-7계층)
- [4. 🎤 TCP 의 연결 및 해제 과정 (3,4-way hands shaking)](#-tcp-의-연결-및-해제-과정-34-way-hands-shaking)
- [5. 🎤 DNS & 웹 통신 흐름](#-dns--웹-통신-흐름)
- [6. 🎤 Blocking I/O & Non-Blocking I/O](#-blocking-io--non-blocking-io)
- [7. 🎤 L7, L4 스위치 & 로드밸런싱](#-l7-l4-스위치--로드밸런싱)
- [8. 🎤 HTTP 진화 과정](#-http-진화-과정)
- [9. 🎤 HTTPS](#-https)
- [10. 🎤 쿠키 & 세션](#-쿠키--세션)
- [11. 🎤 프록시 서버](#-프록시-서버)
- [12. 🎤 SOP와 CORS](#-sop와-cors)
- [13. 🎤 네트워크 토폴로지](#-네트워크-토폴로지)
- [14. 🎤 REST API & RESTful](#-rest-api--restful) <br/><br/>

## <span style="color: #FFA500">**🎤 네트워크의 기초**</span>

## <span style="color: #FFA500">**🎤 대역폭**</span>

**Q. 만약 트래픽이 100만큼 들어오고 처리량이 50이라면 시스템의 처리과정은 어떻게 되나요?**

A. 시스템은 50의 트래픽만을 처리할 수 있고 나머지 50의 트래픽은 처리되지 않고 버려지거나 대기 상태에 있게 된다. <br/><br/>

**Q.  100Mbps라는 대역폭을 가진 서버가 있고 한 사용자당 100kbps로 동영상 파일을 요청한다고 했을 때, 최대 동접자수는?**

A. 최대 동접자수 : 100Mbps / 100kbps = 약 1000명 <br/><br/>

## <span style="color: #FFA500">**🎤 OSI 7계층**</span>

**Q. *OSI 7 계층으로 나눈 이유가 무엇인가?***

A. 네트워크 통신 과정을 파악하기 쉽게하기 위해 도입되었습니다. 통신과정을 계층별로 표준화해서 다양한 HW/SW에 대해 호환성을 보장할 수 있습니다. 계층별로 표준화가 되어있기 때문에, 특정 과정에 이슈가 있을경우 해당 계층의 이슈만 해결하면됩니다. <br/><br/>

**Q. *Mac 주소란 무엇인가?***

A. NIC의 주소. 네트워크상에서 장비를 구별할 수 있는 고유한 식별자. 48bit로 되어있고, L2에서 사용한다. <br/><br/>

**Q. *라우팅이 무엇인가?***

A. 네트워크 안에서 최적의 경로를 선택하는 과정. L3에서 사용하며, bgp, ospf등 다양한 알고리즘이 있다. <br/><br/>

**Q. *전송 계층에서 사용하는 프로토콜은 무엇이 있는가?***

A. TCP/UDP

TCP는 연결 지향적이고 신뢰할 수 있는 데이터전송을 보장하는 반면, UDP는 비연결형 서비스를 제공하며, 실시간 응용프로그램에서 선호된다. <br/><br/>

**Q. 계층 별로 역할을 설명하라**

A. 

- 물리 계층(1계층): 데이터 전송과 수신을 위한 물리적인 매체와 인터페이스를 제공합니다.
- 데이터 링크 계층(2계층): 물리 계층을 통해 안전하게 데이터를 전송하기 위한 프레이밍, 오류 검출 및 수정 기능을 제공합니다.
- 네트워크 계층(3계층): 다양한 **네트워크 간의 데이터 전송과 라우팅**을 담당합니다.
- 전송 계층(4계층): 종단 간의 신뢰성 있는 **데이터 전송**을 관리합니다.
- 세션 계층(5계층): 응용 프로그램 간의 세션을 생성, 관리, 종료하는 기능을 합니다.
- 표현 계층(6계층): 데이터 형식 변환, **암호화 및 압축**을 담당합니다.
- 응용 계층(7계층): 최종 사용자와 가장 가까운 계층으로, 네트워크 소프트웨어 UI 및 API를 포함합니다. <br/><br/>

**Q. *응용 계층에서 사용되는 프로토콜을 아는 대로 설명하라.***

A. HTTP, FTP, SMTP 등등

HTTP는 웹서버와 클라이언트간 통신을 위해 사용

FTP는 파일 전송을 위해 사용

SMTP는 이메일 전송을 위해 사용 <br/><br/>

## <span style="color: #FFA500">**🎤 TCP 의 연결 및 해제 과정 (3,4-way hands shaking)**</span>

**Q. TCP와 UDP의 차이를 설명해주세요**

A. TCP는 연결 지향적 프로토콜로, 데이터가 정확하게 도착했는지 확인하기 때문에 신뢰성이 높습니다. 반면, UDP는 비연결형 프로토콜로, 데이터의 정확한 전송을 보장하지 않지만 데이터 전송 속도가 빠르다는 장점이 있습니다. <br/><br/>

**Q. 3 way handshake와 4 way handshake를 설명해주세요**

A. 3 way handshake는 TCP 연결을 시작할 때 사용되는 과정입니다. 처음에 클라이언트가 SYN을 통해 연결 요청을 보내면, 서버는 그에 대한 응답으로 ACK플래그를 보냄과 동시에, 연결을 요청하는 SYN플래그를 함께 보냅니다. 그 후 클라이언트가 서버의 SYN에 대한 응답으로 ACK플래그를 보냄으로써 연결을 확립합니다.

4 way handshake는 TCP 연결을 종료할 때 사용되는 과정입니다. 처음에 클라이언트가 FIN플래그를 보내면, 이를 받은 서버가 ACK플래그를 보냅니다. 그 후 서버 역시 연결 해제할 준비를 마치면 FIN플래그를 보내고 이를 받은 클라이언트가 ACK플래그를 보냄으로써 연결을 안전하게 종료합니다. <br/><br/>

**Q. 4 way handshake에서의 TIME-WAIT 상태에 대해서 설명해주세요**

A. TIME-WAIT 상태는 의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지하기 위한 것입니다. 예를 들어 Server에서 FIN 플래그를 전송하기 전에 전송했던 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황을 대비해 FIN 플래그를 수신하더라도 일정 시간(Default : 240초)동안 잉여 패킷을 기다리는 과정을 말합니다. 만약 에러로 인해 종료가 지연되다가 시간이 초과되면 CLOSED 상태로 변경됩니다. <br/><br/>

## <span style="color: #FFA500">**🎤 DNS & 웹 통신 흐름**</span>

**Q. https://google.com에 접속했을 때 일어나는 일을 설명해주세요.**

A. 

1) Host가 google.com을 검색하면 OS에서 NIC(network Interface Card, 이거 하나 당 IP하나씩 받을 수 있음)를 통해 요청을 보내야 한다. Host는 google의 IP주소를 알아야 한다.

2) 내가 IP주소를 아는지 모르는지 판단하기 위해 hosts와 DNS cache에서 mapping 정보를 확인한다.(DNS Lookup)

3) 2)에서 없으면 DNS서버로 요청을 보내서 응답을 받는다. (공유기 / 라우터가 DNS를 알고있음. 인터넷 망을 통해 DNS서버로 요청을 한다.)

4) 그 IP주소로 http request를 보내고 응답을 받는다. (해당 IP로 가는 경로는 중간중간의 Router들의 Routing Table에 저장되어있다.) <br/><br/>

**Q. DNS에 대해서 설명해주세요.**

A. DNS(Domain Name System)는 도메인 이름을 IP주소로 변환하거나 그 반대의 역할을 수행하는 시스템입니다. <br/><br/>

## <span style="color: #FFA500">**🎤 Blocking I/O & Non-Blocking I/O**</span>

**Q. Blocking 과 non-Blocking  각각의 정의 설명**

A. 

**Blocking: 단 각 소켓마다 두 가지 버퍼(send, receive)가 있다는 걸 깔고 시작.**

I/O 작업을 요청한 프로세스/스레드는 요청이 완료될 때까지 블락됨

I/O 작업이 진행되는 동안 유저 프로세스가 자신의 작업을 중단한 채, I/O가 끝날 때까지 대기하는 방식

I/O가 호출되면 (I/O 함수가) 제어권을 가져가서 어플리케이션이 멈추게 됨 <br/><br/>

**non-Blocking : 프로세스/스레드를 block시키지 않고, 요청에 대한 현재 상태를 즉시 리턴**

A함수가 I/O 작업을 호출했을 때 I/O 작업이 완료될 대까지 A 함수의 작업을 중단하지 않고 I/O 호출에 대해 즉시 리턴하고, A 함수가 이어서 다른 일을 수행할 수 있도록 하는 방식

제어권을 어플리케이션이 가지고, 어플리케이션은 계속 동작함. 필요한 경우 polling과 같은 상태 확인은 가능

이는 커널이 시스템 콜을 받자마자 CPU 제어권을 다시 어플리케이션에게 넘겨주고, 따라서 어플리케이션은 I/O 작업이 완료되기 전에 다른 작업을 수행할 수 있다. <br/><br/>

**Q. Blocking 방식에서 A함수가 B함수에게 I/O작업을 요청했을 때 요청이 처리되는 방식을 설명해주세요.**

A.

- 어플리케이션(thread)에서 Read()를 호출해 커널에 read I/O를 요청하면, read가 끝날 때까지 application은 block이 되어 다른 작업을 하지 못한다.
- 커널의 I/O 작업이 완료될 때까지 제어권을 커널에서 가지고 있기 때문에, 유저 프로세스는 read I/O가 수행될 때까지는 어플리케이션이 다른 작업을 수행하지 못한다는 것을 의미 <br/><br/>

**Q. non-Blocking 방식에서 A함수가 B함수에게 I/O작업을 요청했을 때 요청이 처리되는 방식을 설명해주세요.**

A. 

- read I/O를 하기 위해 systemcall을 호출하면, kernel 모드로 context-switching된다. 이 때 kernel 모드에서는 read I/O 작업을 실행시킨다. 이후 커널의 I/O 작업 완료 여부와는 무관하게 즉시 응답한다. 아직 리턴할 데이터가 준비되지 않았기 때문에 리눅스 기준으로는 -1 리턴. ( EAGAIN or EWOULDBLOCK 이라는 에러 코드와 함께!)
- 이때 thread는 block I/O와는 다르게 이어서 바로 다른 코드 실행! 원래 내 하던일이나 마저 해야겠다~
- 그렇게 다른 코드를 실행하던 중 kernel 로부터 read 응답이 준비되었다는 신호가 올거야. 그래도 일단 내 하던 일부터 마저 다 끝낸 후에 read non-blocking system call 다시 호출.
- 그럼 다시 kernal 로 context-switching이 되고, 이때는 데이터가 준비된 상태이기 때문에 커널이 다시 user space 쪽으로 데이터를 전송 <br/><br/>

**Q. (희망할 경우에만 준비) 동기/비동기를 나누는 기준이랑 Block/non-Block을 나누는 기준이 어떻게 다른가요?**

A. 

동기와 비동기는 ***작업완료 여부를 신경쓰는가***(완료 여부를 확인하는가)에 따라 달라진다.

- ***동기(Synchronous)***
    - 요청을 보낸 후 return 받아야 다음 동작 실행
    - 현재 작업의 응답이 끝남과 동시에 다음 작업 요청
    - 함수를 호출하는 곳에서 호출되는 함수가 결과를 반환할때까지 대기
    - 작업 완료 여부를 계속해서 확인
- ***비동기(Asynchronous)***
    - 요청을 보낸 후 return과 상관없이 다음 동작 실행
    - 현재 작업의 응답이 끝나지 않은 상태에서 다음 작업 요청
    - 함수를 호출하는 곳에서 결과를 기다리지 않고 다른 함수(callback)에서 결과 처리
    - 작업 완료 여부를 확인하지 않음

블로킹과 넌블로킹은 ***제어권이 넘어오는가***(함수의 리턴시기 및 제어권)에 따라 달라진다.

- ***블로킹(Blocking)***
    - 호출된 함수가 자신의 작업을 모두 끝낼 때까지 제어권을 가지고 있어 호출한 함수가 대기
    - 제어권이 호출된 함수로 넘어감
    - 제어권을 가지게 된 호출된 함수가 작업을 모두 끝낸 후에서야 응답 값과 제어권을 원래 함수로 return
    - 기존 함수는 제어권이 없는 상태라 작업 불가
- ***논블로킹(NonBlocking)***
    - 호출 된 함수가 바로 return 하여 제어권을 돌려주어 호출한 함후에게 다른 작업 수행이 가능하도록
    - 함수가 호출되어도 호출한 함수는 제어권을 넘겨주었다가 바로 돌려받음
    - 기존 함수가 제어권을 가지고 있어 다른 작업 가능 <br/><br/>

## <span style="color: #FFA500">**🎤 L7, L4 스위치 & 로드밸런싱**</span>

**Q.  로드 밸런싱(Load Balancing) 에 대해 설명해주세요.**

A. **서버에 가해지는 부하를 적절하게 분산시켜주는 장치 또는 기술**을 뜻한다. 처음에 구축했던 서버가 수용할 수 있는 범위보다 더 큰 트래픽으로 기존 서버를 사용할 수 없게 되는 경우가 있는데, 이 때 서버 트래픽을 분산시키기 위해 사용한다. <br/><br/>

**Q. 로드 밸런싱 알고리즘에는 뭐가 있나요?** 

A. 라운드로빈, 최소연결, 가중치 분배 알고리즘등 <br/><br/>

Q. 꼬리질문 - 로드 밸런싱 알고리즘 중 대표적인 라운드 로빈, 최소 연결 방식 에 대해 설명해보세요. 

A. **라운드 로빈(Round Robin)** 알고리즘은 서버에 들어오는 요청들을 순서대로 돌아가면서 배정하는 알고리즘이다. 하나씩 배정하기 때문에 여러 대의 서버 성능이 비슷하고 세션이 오래 지속되지 않는 경우에 적합하다.

반면, **최소 연결 방식**(Least Connection Method) 은 요청이 서버에 들어왔을 때 가장 연결이 적은 서버에 배정하는 알고리즘이다. 서버 트래픽이 일정하지 않고 세션이 길어질 때 적합하다. <br/><br/>

**Q. L4 로드 밸런싱과 L7 로드 밸런싱에 대해 설명하고, 차이를 말해보세요.**

A. L4 로드 밸런싱은 Layer 4(네트워크 계층 또는 트랜스포트(전송) 계층) 의 정보를 바탕으로 트래픽을 분산하는 방식이다. TCP, UDP, IP 정보들을 바탕으로 분산한다. 정보가 어떻게 생겼는지 보지 않고 패킷 레벨에서만 트래픽을 분산하기 때문에 속도가 빠르고 효율성이 높으며 L7 로드 밸런싱보다 저렴하다.

반면, L7 로드 밸런싱은 ****Layer 7(애플리케이션(응용) 계층) 의 정보를 바탕으로 요청을 분산한다. HTTP Header, Cookie 등과 같이 사용자가 요청한 정보들을 바탕으로 트래픽을 분산하기 때문에 섬세한 라우팅이 가능하고 비정상적인 트래픽을 판별할 수 있다. 하지만, L4 로드 밸런싱보다 비용이 높다.

## <span style="color: #FFA500">**🎤 HTTP 진화 과정**</span>

**Q. HTTP Protocol의 주요 버전들은 어떤 개선사항을 가지고 있나요?**

A. 

1. **HTTP/0.9 (1991)**:
    - 최초의 HTTP 버전으로, 매우 단순한 프로토콜.
    - 오직 GET 요청만을 지원하며, HTML 문서만을 반환 가능.
2. **HTTP/1.0 (1996)**:
    - HTTP 헤더의 도입으로 요청과 응답이 메타 데이터를 포함할 수 있게 됨.
    - 상태 코드 등을 지원하여 오류 유형을 명확히 구분
3. **HTTP/1.1 (1997, 개선됨 1999)**:
    - 연결 재사용(Keep-Alive)을 통해 여러 요청과 응답이 단일 연결을 통해 이루어질 수 있게 됨.
    - 청크 전송, 압축, 요청 파이프라이닝 등의 기능이 추가됨.
    - 호스트와 같은 새로운 헤더들이 도입되어 가상 호스팅이 가능해짐.
4. **HTTP/2 (2015)**:
    - 프로토콜의 효율성과 속도를 개선하기 위해 도입된 이진 프로토콜.
    - 서버 푸시 기능을 도입하여 서버가 클라이언트의 요청에 더욱 빠르게 응답할 수 있음.
    - 멀티플렉싱을 통해 하나의 연결에서 여러 요청과 응답이 동시에 이루어질 수 있음.
    - 헤더 압축을 통해 프로토콜 오버헤드 감소. <br/><br/>

**Q. HTTP/3 이전 버전과의 주요한 차이가 무엇인지 설명해주세요.**

A.

HTTP/3은 이전 버전들이 TCP를 사용하는 것과는 다르게 UDP 기반의 QUIC 프로토콜을 사용합니다. 이는 몇 가지 주요한 차이점과 이점을 가짐

- **QUIC 프로토콜 사용**: QUIC는 연결 설정 시간을 줄이고, 연결의 재설정과 관련된 지연을 감소시킵니다. 이는 특히 네트워크 환경이 변할 때(예: 사용자가 이동 중일 때) 연결의 안정성을 유지하는 데 도움이 됩니다.
- **내장된 TLS 지원**: QUIC은 기본적으로 TLS 암호화를 내장하여 보안 통신이 기본적으로 제공됩니다. 이전 HTTP 버전에서는 HTTPS를 사용할 때만 TLS가 적용되었습니다.
- **연결 마이그레이션 지원**: 사용자의 IP 주소나 포트가 변경되어도 기존의 연결을 유지할 수 있어 모바일 기기 사용에 효과적입니다.
- **스트림 수준의 오류 복구**: QUIC은 각 스트림이 독립적으로 오류를 복구하므로 전체 연결에 영향을 미치지 않고 특정 스트림의 문제를 해결할 수 있습니다.
- **향상된 연결 및 통신 효율**: HTTP/2의 멀티플렉싱 기능을 개선하여, 패킷 손실이 하나의 스트림에만 영향을 미치고 다른 스트림은 영향받지 않도록 합니다. <br/><br/>

## <span style="color: #FFA500">**🎤 HTTPS**</span>

## <span style="color: #FFA500">**🎤 쿠키 & 세션**</span>

## <span style="color: #FFA500">**🎤 프록시 서버**</span>

## <span style="color: #FFA500">**🎤 SOP와 CORS**</span>

## <span style="color: #FFA500">**🎤 네트워크 토폴로지**</span>

## <span style="color: #FFA500">**🎤 REST API & RESTful**</span>