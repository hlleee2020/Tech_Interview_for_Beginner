# 인덱스
Index는 '색인'이라는 뜻이다. 쉽게 찾아볼 수 있도록 일정한 순서에 따라 놓은 목록으로 데이터를 빠르고 찾을 수 있는 수단으로 테이블에 대한 조회 속도를 높여 주는 자료구조이다.

예를 들어 10개의 튜플 중 원하는 튜플을 찾기 위해서는 위에서부터 차례대로 찾으면 금방 찾을 수 있다. 하지만 튜플이 100만 개가 있다면 이를 다 찾기 위해서 매우 많은 탐색을 해야한다. 따라서 조건을 만족하는 튜플을 빠르게 조회하기 위해서 인덱스를 사용한다.

- 인덱스는 항상 최신의 정렬상태를 유지한다.
- 인덱스도 하나의 데이터베이스 객체이다.
- 데이터베이스 크기의 약 10% 정도의 저장공간 필요하다.

# 인덱스 알고리즘

## Full Table Scan
### Full Table Scan 특징
1. 순차적으로 접근
2. 접근 비용 감소
### Full Table Scan 사용
1. 적용 가능한 인덱스가 없는 경우
2. 인덱스 처리 범위가 넓은 경우
3. 크기가 작은 테이블에 엑세스 하는 경우

## B-Tree
균형 있는 이진탐색트리의 경우 시간복잡도는 O(log n)이지만 편향된 이진탐색트리의 경우 O(n)으로 시간복잡도가 나쁘다.
B-Tree는 Balanced-Tree라고도 하며 특징은 크게 세 가지가 있다.
1. 트리 높이가 같다.
2. 자식 노드를 2개 이상 가질 수 있다.
3. 기본 데이터베이스 인덱스 구조이다.

B-Tree는 따로 파트가 분배되어 있기 떄문에 다음에 알아보자.

# 인덱스 종류
인덱스의 종류로는 클러스터링 인덱스(clustering index)와 논-클러스터링 인덱스(non-clustering index)가 있다.

 클러스터(cluster)는 무리, 군집이라는 뜻이다. 클러스터링(clustering)이란 실제 데이터와 무리를 이루는 것이고 논-클러스터링(non-clustering)은 실제 데이터와 무리를 이루지 않는다.

 즉, 클러스터링 인덱스는 실제 데이터와 같은 무리의 인덱스이며 논-클러스터링은 실제 데이터와 다른 무리의 별도의 인덱스인 것이다.
 
 클러스터링 인덱스의 예시로는 순서대로 정렬되어 있는 실제 데이터가 정렬된 사전과 같은 것이 있고 논-클러스터링 인덱스의 예시로는 책의 제일 뒤에 초성 순으로 정렬되어 있는 찾아보기 페이지와 같은 것이 있다. 

## 클러스터링 인덱스(Clustering Index)
### 특징
1. 데이터를 인덱스 키 값의 물리적 순서대로 디스크에 저장하기 때문에 실제 데이터 자체가 정렬된다
2. 테이블 당 1개만 존재 가능하다.
3. 리프 페이지가 데이터 페이지이다.
  - 페이지: 데이터가 저장되는 단위()
4. 아래의 제약조건 시 자동 생성된다.

- primary key(우선순위)
- unique + not null

클러스터링 인덱스를 사용하면, 인덱스 검색을 통해 해당 데이터를 바로 찾아갈 수 있으며, 인덱스 키 값에 기반한 범위 검색이나 순차 접근이 매우 효율적이다.

이 구조의 장점은 데이터 접근 시간을 최소화할 수 있다는 것이다. 인덱스를 통해 데이터에 접근할 때, 추가적인 데이터 페이지로의 접근 없이 리프 페이지에서 바로 데이터를 읽을 수 있기 때문이다. 하지만, 데이터 삽입이나 삭제, 업데이트로 인한 인덱스 키 값의 변화는 데이터 페이지의 물리적 재배치를 요구할 수 있어, 이러한 작업의 비용이 비클러스터링 인덱스에 비해 높을 수 있다.

### 추가 방법
```
INSERT INTO 테이블명 (컬럼1, 컬럼2, 컬럼3, ...)
VALUES (값1, 값2, 값3, ...);
```

```
INSERT INTO employees (employee_id, name, department, salary)
VALUES (101, 'John Doe', 'Finance', 50000);
```

## 논-클러스터링 인덱스(Non-Clustering Index)

논-클러스터링 인덱스는 보조 인덱스, 세컨더리 인덱스(Secondary Index)라고도 한다.

### 추가 방법
```
// 방법 1
ALTER TABLE member
ADD CONSTRAINT unq_name UNIQUE(name);

// 방법 2
CREATE UNIQUE INDEX unq_idx_name
ON member(name);

// 방법 3
CREATE INDEX idx_name
ON member(name);
```

### 특징

1. 실제 데이터 페이지는 그대로


2. 별도의 인덱스 페이지 생성 -> 추가공간 필요
3. 여러 개 존재
4. 리프 페이지에 실제 데이터 페이지 주소를 담고 있음
5. unique 제약조건 적용 시 자동 생성
6. 직접 index 생성 시 non-clustering index 생성

# 인덱스 적용 기준
카디널리티(그룹 내 요소의 개수)가 높은 것에 적용을 해야한다.
카디널리티가 높다는 것은 중복 수치가 낮은 것이기 때문에 카디널리티가 높은 컬럼에 인덱스를 적용해야 된다.
1. 카디널리티가 높은(중복도가 낮은) 컬럼
2. WHERE, JOIN, ORDER BY 절에 자주 사용되는 컬럼

  - 인덱스는 추가 공간이 필요하다.
  - 조건 절이 없다면 인덱스가 사용되지 않는다.

3. INSERT / UPDATE / DELETE가 자주 발생하지 않는 컬럼
4. 규모가 작지 않은 테이블

# 인덱스 사용 시 주의사항
1. 잘 활용되지 않는 인덱스는 과감히 제거하자

- WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
- 불필요한 인덱스로 성능저하가 발생할 수 있다.

2. 데이터 중복도가 높은 컬럼은 인덱스 효과가 적다

3. 자주 사용되더라도 INSERT / UPDATE / DELETE가 자주 일어나는지 고려해야 한다.
- 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2 : 8 또는 1 : 9이다.
- 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법이다.

# 출처
- https://www.youtube.com/watch?v=edpYzFgHbqs
- https://mangkyu.tistory.com/96