
### **✍ DB 기본 3줄 요약**

- **데이터베이스(Database, DB)란?** : 데이터의 저장소.
- **DBMS(Database Management System, 데이터베이스 관리 시스템)란?** 데이터베이스를 운영하고 관리하는 소프트웨어.
    - 계층형, 망형, 관계형 DBMS 중 대부분의 DBMS가 테이블로 구성된 관계형 DBMS(RDMBS)형태로 사용됨.
- **SQL(Structured Query Language)란?** 구조화된 질의 언어라는 뜻으로 관계형 데이터베이스에서 사용되는 언어. 표준 SQL을 배우면 대부분의 DBMS를 사용할 수 있음.

[[데이터베이스 이해하기] Database(DB), DBMS, SQL의 개념](https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/)

---

# ERD

## 1️⃣ `E-R Diagram`란 무엇인가?

<aside>
💡 ✨요약✨

- ✨E-R Diagram(Entity Relationship Diagram)이라 불리는 ERD는 관계형 데이터베이스의 엔터티, 속성 및 관계를 시각적으로 나타내기 위해 DB 설계단계중 개념적 모델링에서 사용되는 표기 방법이다.
    - 데이터 모델링 ❓
        
        개념적 모델링 단계 -> 논리적 모델링 단계 -> 물리적 모델링 단계
        
        1. 개념적 모델링은 전체적인 비전을 구축하는 단계. Entity 를 도출하고 ERD를 작성하는 단계이다.
        2. 논리적 모델링은 ERD 를 사용할 특정 DBMS 의 논리적 자료구조에 맞게 매핑
            
            (Mapping) 하는 과정이다. 예를들어 RDBMS 를 사용한다고 하면, ERD를 RDB로 매핑한다. 테이블 설계와 정규화도 여기서 이루어진다.
            
        3. 물리적 모델링은 사전적으로 작성된 논리적 데이터 모델을 관계형 데이터베이스의 물리적인 구조(Schema)를 작성해가는 과정. 데이터의 저장공간, 데이터의 분산, 데이터 저장 방법 등을 함께 고려하는 단계
            
            > 스키마 : ‘데이터의 구조’ 또는 ‘데이터베이스의 설계’ 를 의미
            데이터베이스 스키마는 관계형 데이터베이스에서 데이터가 구조화되는 방식을 정의한다.  여기에는 테이블 이름, 필드, 데이터 유형, 그리고 이러한 엔티티 간의 관계 등 논리적 제약조건이 포함된다. 일반적으로 스키마는 시각적 표현을 사용하여 데이터베이스의 아키텍처를 전달하며, 조직의 데이터 관리 규율의 기반이다. 이 데이터베이스 스키마 설계 프로세스를 물리적 모델링이라고 한다.
            > 
- ✨데이터베이스 설계의 핵심
</aside>
<br>

- 데이터베이스 설계 단계에서 맨 처음 단계인 개념적 모델링 단계에서 주로 사용
- 데이터베이스 구조를 한눈에 알아보기 위해 사용 됨
- 쿼리문을 작성할 때 테이블들이 구조화된 다이어그램을 보면서 도움을 받을 수 있다.
- 데이터의 다양한 특징을 확인할 수 있어 요구사항을 파악하기 쉬움
- 현재 가장 인기있는 관계형 데이터베이스의 테이블 구조로 매핑 하기에도 쉬워 인기가 많은 방식
- 응용 프로그램의 데이터 요구 사항을 모델링하는 데 사용되며 **`데이터베이스 설계의 핵심 구성 요소`**
<br><br><br>
✨ ERD의 구성 요소

- Entity(엔티티), Attribute(속성), **Relationship**(관계)
    
    ✓ **Entity** : 설계 중인 시스템과 관련된 실제 객체 또는 개념.
    
    - 상세설명 🙋‍♀️
        
        데이터베이스에서 엔티티는 정보의 단위를 나타낸다. 엔티티는 해당 정보의 속성들을 포함하며, 데이터베이스에서 테이블로 표현될 수 있다.
        
        간단한 예) "고객(Customer)"과 "주문(Order)" 엔티티
        
        1. **고객(Customer) 엔티티:**
            - 이 엔티티는 고객에 대한 정보를 나타낸다.
            - 속성(Attribute): 아이디(CustomerID), 이름(Name), 이메일(Email), 등급(Level) 등
            - 이 정보는 데이터베이스에서 하나의 테이블로 표현될 수 있다.
            
            ```
            plaintextCopy code
            +-------------+---------+----------------------+--------+
            | CustomerID  | Name    | Email                | Level  |
            +-------------+---------+----------------------+--------+
            | 1           | Alice   | alice@example.com    | Gold   |
            | 2           | Bob     | bob@example.com      | Silver |
            | 3           | Charlie | charlie@example.com  | Bronze |
            +-------------+---------+----------------------+--------+
            
            ```
            
        2. **주문(Order) 엔티티:**
            - 이 엔티티는 주문에 대한 정보를 나타낸다.
            - 속성(Attribute): 주문번호(OrderID), 고객번호(CustomerID), 주문일자(OrderDate), 금액(TotalAmount) 등
            - 이 정보는 데이터베이스에서 또 다른 테이블로 표현될 수 있다.
            
            ```
            plaintextCopy code
            +---------+-------------+-------------+--------------+
            | OrderID | CustomerID  | OrderDate   | TotalAmount  |
            +---------+-------------+-------------+--------------+
            | 101     | 1           | 2022-01-01  | 150.00       |
            | 102     | 2           | 2022-01-02  | 75.50        |
            | 103     | 3           | 2022-01-03  | 30.25        |
            +---------+-------------+-------------+--------------+
            
            ```
            
        
        이러한 엔티티들은 비즈니스 도메인에서의 실제 객체들을 데이터베이스에 효과적으로 저장하고 관리하는 데 사용된다. 엔티티 간의 관계도 나타낼 수 있으며, 이를 통해 복잡한 데이터 모델을 만들어 각 엔티티 간의 연결을 표현할 수 있다.
        
    
    ✓ **Attribute** : 각 엔터티에 특정한 세부 정보를 설명.
    
    ✓ **Relationship** : Entity간의 관계를 의미한다. 두 Entity간에 선을 긋고, 관계 명칭을 기록하게 된다.
    
<br><br>

✨ 각 구성요소 예

✓ **Entity**

학교용 데이터베이스를 설계하는 경우 학생, 교사, 과정 및 교실과 같은 엔터티가 있을 수 있다.

✓ **Attribute**

학생 엔터티의 속성에는 이름, 나이 및 ID 번호가 포함될 수 있다.

✓ **Relationshop**

한 학생이 여러 과정에 등록되어 있을 수 있다. 학생 테이블과 과정 테이블을 맺는 것이 관계이다.

📌 ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는데는 유용하지만 비정형 데이터를 충분히 표현할 수 없다는 `단점`이 있다.

> 비정형 데이터 : 비구조화 데이터. 미리 정의된 데이터 모델, 또는 스키마를 따르지 않고 행과 열로 쉽게 구성할 수 없는 데이터.
> 

## 2️⃣ ERD의 표기법

1. **첸 표기법 (Chen Notation):**
    
    ✓ 실무에서는 잘 사용되지 않는 방식.
    
    ✓ 엔티티는 직사각형, 속성은 타원형, 관계는 마름모 형태로 표현된다. 이 표기법은 E-R 다이어그램의 기본 구성 요소를 간결하고 명확하게 표현할 수 있다.
    
    <image src="./img/db_erd_and_normalization_1.png" width = "400px" height="180px" alt = "chen notation img" >
    <image src="./img/db_erd_and_normalization_2.png" width = "400px" height="180px" alt = "chen notation img" >
    

<aside>
💡 entity : 고객, 주문서
고객의 attribute : 고객 번호, 성명, 주소
주문서의 attribute : 주문번호, 품명, 수량, 금액

`밑줄 친 주문 번호와 고객 번호는 기본 키`

관계 : 고객과 주문서의 주문 관계는 1:N 관계.
      즉 한 사람의 고객이 다수의 주문을 할 수 있고
      주문서 1개는 특정인의 주문서로 되어 있다.

</aside>

> 기본 키
> 
> - 상세 설명
>     
>     각 행의 정보들을 식별할 수 있는 정보(주문 번호, 고객 번호)를 표현.
>     
>     - 유일성과 최소성을 가지며(후보키), 해당 레코드를 식별할때 기준이 되는 반드시 필요한 키이다.
>     - 조건
>         - 값의 변동이 잦은 후보키는 기본키로 부적절하다.
>         - 테이블의 정보를 최대한 빠르게 검색해야 하므로 간단한 정보일수록 좋다.
>         - NULL값을 가질수 있는 속성이 포함된 후보키는 부적절하다.
>         - 후보키중 단순한 키를 기본키로 선택한다.
>         - 하나의 테이블에는 반드시 하나의 기본키만 존재한다.
>     
>     추가 `키` 공부 아래 링크 참고
>     
>     [[DB] 기본키 / 외래키 / 후보키 / 복합키  개념](https://velog.io/@kon6443/DB-%EA%B8%B0%EB%B3%B8%ED%82%A4-%EC%99%B8%EB%9E%98%ED%82%A4-%ED%9B%84%EB%B3%B4%ED%82%A4-%EB%B3%B5%ED%95%A9%ED%82%A4-%EA%B0%9C%EB%85%90-4x1bgz5w)
>     

2. **까마귀발 표기법 (Crow's Foot Notation)**
    
    ✓ 실무에서 가장 많이 사용되는 방법
    
    ✓ 이 표기법은 관계의 다중성을 나타내는 데 초점을 맞춤
    
    ✓ 엔티티는 직사각형, 속성은 엔티티 내에 표시되며, 관계는 선으로 표시되고 관계(1:1, 1:N, M:N)를 나타내는 '까마귀 발' 기호로 끝난다.
    
    ✓ `IE표기법`, `바커 표기법` 등 다양한 형태의 변형이 존재.
    
    예) 학교-학생(1:M)
    
    <image src="./img/db_erd_and_normalization_14.png" width = "400px" height="180px" alt = "crow's foot img" >
    
    <image src="./img/db_erd_and_normalization_15.png" width = "400px" height="180px" alt = "crow's foot img" >
    
    <image src="./img/db_erd_and_normalization_16.png" width = "400px" height="100px" alt = "crow's foot img" >
    
    출처: http://www.dbguide.net/db.db?cmd=view&boardUid=12845&boardConfigUid=9&boardIdx=31&boardStep=1
    

### 정보 공학 표기법(Information Engineering Notation) `IE표기법`

- 실무에서 가장 많이 사용

**Entity와 Attribute**

- Entity의 이름을 상단에 표기.
- Entity 이름 하단에 그림과 같이 좌측에는 PK, FK 등의 정보 표기, 우측에는 속성의 이름을 표기한다. 속성의 옆에 보통 ()를 열고 데이터 타입을 표기 할 수도있다.
    
    <image src="./img/db_erd_and_normalization_3.png" width = "200px" height="180px" alt = "ie notation img" >

### relation

- 각 Entity 간의 관계는 기본적으로 실선과 점선으로 표현
    
    실선은 식별 관계를 나타낸다. 식별관계는 부모 Entity의 PK 또는 유니크키를 자식 Entity의 PK로 사용하는 관계이다. 즉, 자식 Entity 는 부모 Entity 가 존재해야 존재할 수 있다.
    
    <image src="./img/db_erd_and_normalization_4.png" width = "400px" height="80px" alt = "ie notation img" >
    
    점선은 비식별 관계를 나타낸다. 비식별 관계란 부모 Entity의 PK 또는 유니크키를 자식 Entity 에서 외래키로 사용하는 관계이다. 즉, 자식 Entity 는 부모의 존재유무와 관계 없이 독립적으로 존재할 수 있다.
    

**관계 표현**

<image src="./img/db_erd_and_normalization_5.png" width = "400px" height="180px" alt = "ie notation img" >

<br>

- **학생과 학급 간의 관계 ERD 예시**

<image src="./img/db_erd_and_normalization_13.png" width = "400px" height="180px" alt = "ie notation img" >

> 학급과 학생은 비식별 관계로 학생(자식 Entity)이 학급(부모 Entity)의 존재 유무와 관계 없이 독립적으로 존재 가능. - 점선 표시
> 
> 
> 이때 학급 한개에 학생은 여려명이 있는 1:N의 관계가 되어 까마귀 발로 관계를 표시.
> 

### 바커 표기법 (Barker Notation) `바커 표기법`

- Entity는 네 부분의 모서리가 둥근 형태인 Soft-Box로 표현
- Entity 이름은 Box 내부 상단에 표시
- Attribute 중 **필수로 값을 입력하며 식별자인 속성은 `#`**를 표시
- Attribute 중 **필수로 값을 입력하여야 하는 속성은 ` `** 를 표시
- Attribute 중 **선택적인 입력을 하여야 하는 속성은 `o`** 를 표시
    
    <image src="./img/db_erd_and_normalization_12.png" width = "400px" height="350px" alt = "barker img" >
    

### 바커 표기법과 정보 공학법 표기법의 차이

<image src="./img/db_erd_and_normalization_11.png" width = "400px" height="250px" alt = "barker img" >

### UML 표기법 (Unified Modeling Language Notation)

- UML은 객체 지향 시스템의 모델링을 위한 표준화된 표기법입니다. 클래스 다이어그램을 사용하여 엔티티와 관계를 나타낸다.
- 데이터베이스의 모델링을 위한 기법이 아니라 객체지향 모델링 표기법이였다가 데이터베이스까지 그 영향을 끼침.

<image src="./img/db_erd_and_normalization_10.png" width = "400px" height="350px" alt = "uml notation img" >

---

# 정규화

## 1️⃣ 정규화의 정의

✨ relation간의 잘못된 종속 관계로 이상현상이 있는 relation을 분해하여 이상현상을 없애는 과정

✨ 릴레이션을 여러 개로 분리하는 과정

✨ 단계별로 구분하여 정규형이 높아질수록 이상현상은 줄어든다.

> 데이터베이스 이상 현상 ❓
> 
> 1. 회원이 한개의 등급을 가져야 하는데 세 개의 등급을 갖는 경우.
> 2. 삭제할때 필요한 데이터가 같이 삭제되는 경우.
> 3. 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안돼서 삽입하기 어려운 상황.

## 2️⃣ 정규형 원칙

- 같은 의미를 표현하는 relation이지만 더 좋은 구조로 만들어야 함
- 자료의 중복성은 감소해야 됨
- 독립적인 관계는 별개의 relation으로 표현해야 함
- 각각의 relation은 독립적인 표현이 가능해야 함

## 3️⃣ 결론

정규화(Normalization)는 데이터베이스 설계에서 중복을 최소화하고 데이터 무결성을 보장하기 위해 데이터를 구조화하는 프로세스이다.

## 4️⃣ 정규화 과정

1. 제1정규형
    
    ```
    1. 각 컬럼이 하나의 속성만을 가져야 한다.
    2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
    3. 각 컬럼이 유일한(unique) 이름을 가져야 한다.
    4. 칼럼의 순서가 상관없어야 한다.
    ```
    
    |  |  |  |
    | --- | --- | --- |
    | 101 | 홍길동 | 운영체제, DB |
    | 102 | 가나다 | C |
    | 103 | 김싸피 | 자바 |
    
    1→ 불만족. 하나의 칼럼에 두 개의 값을 가짐
    
    2,3,4→만족
    
    | 학생번호 | 이름 | 과목 |
    | --- | --- | --- |
    | 101 | 홍길동 | 운영체제 |
    | 101 | 홍길동 | DB |
    | 102 | 가나다 | C |
    | 103 | 김싸피 | 자바 |

2. 제2정규형
    
    ```
    1. 1정규형을 만족해야 한다.
    2. 모든 컬럼이 부분적 종속(Partial Dependency)이 없어야 한다. == 모든 칼럼이 완전 함수 종속을 만족해야 한다.
    ```
    
    - 부분적 종속이란 기본키 중에 특정 칼럼에만 종속되는 것이다.
    - 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어서는 안된다는 것이다.
    
    | 학생번호 | 과목 | 지도교수 | 성적 |
    | --- | --- | --- | --- |
    | 101 | 운영체제 | 홍길동 | 100 |
    | 101 | DB | 박디비 | 60 |
    | 103 | C | 가나다 | 80 |
    | 103 | 자바 | 김싸피 | 90 |
    
    <image src="./img/db_erd_and_normalization_18.png" width = "200px" height="200px" alt = "normalization img" >
    
    - 성적의 특정 값을 알기 위해서는 학생번호 & 과목을 알아햐 한다. ex) 103번의 C 성적 80
    - 하지만 특정 과목의 지도교수는 과목명만 알면 지도교수가 누군지 알 수 있다 ex) 자바의 지도교수 가나다
    - 위 테이블에서 기본키는 (학생 번호, 과목)으로 복합키이다.
    - 근데 지도교수 칼럼은 (학생 번호, 과목)에 종속되지 않고, 과목에만 부분적 종속된다.
    - 따라서 다음과 같이 분해해야 한다.
    
    | 학생번호 | 과목 | 성적 |
    | --- | --- | --- |
    | 101 | 운영체제 | 100 |
    | 101 | DB | 60 |
    | 103 | C | 80 |
    | 103 | 자바 | 90 |
    
    | 과목 | 지도교수 |
    | --- | --- |
    | 운영체제 | 홍길동 |
    | DB | 박디비 |
    | C | 가나다 |
    | 자바 | 김싸피 |
3. 제3 정규형
    
    ```
    1. 2 정규형을 만족해야 한다.
    2. 기본키를 제외한 속성들 간의 이행 종속성 (Transitive Dependency)이 없어야 한다.
    ```
    
    - 이행 종속성이란 A→B, B→C, 일 때 A→C가 성립하면 이행 종속이라고 한다.
    
    | ID | 등급 | 할인율 |
    | --- | --- | --- |
    | 101 |  Vip | 40% |
    | 102 | Gold | 20% |
    | 103 | Bronze | 10% |
    
    <image src="./img/db_erd_and_normalization_19.png" width = "200px" height="130px" alt = "normalization img" >
    
    - ID를 알면 등급을 알 수 있다. 등급을 알면 할인율을 알 수 있다. 따라서 ID를 알면 할인율을 알 수 있다. 따라서 이행 종속성이 존재하므로 제3 정규형을 만족하지 않는다.
    - 아래와 같이 분해한다.
    
    | ID | 등급 |
    | --- | --- |
    | 101 |  Vip |
    | 102 | Gold |
    | 103 | Bronze |
    
    | 등급 | 할인율 |
    | --- | --- |
    |  Vip | 40% |
    | Gold | 20% |
    | Bronze | 10% |
    
4. 보이스/코드 정규형 (Boyce-Codd Normal Form, BCNF) 
    
    ```
    1. 3정규형을 만족해야 한다.
    2. 모든 결정자가 후보키 집합에 속해야 한다.
    ```
    
    - 제 3 정규형을 좀 더 강화한 버전이다.
    - 모든 결정자가 후보키 집합에 속해야 한다는 뜻은, 후보키 집합에 없는 칼럼이 결정자가 되어서는 안된다는 뜻이다.
    
    | 학생번호 | 과목 | 지도교수 |
    | --- | --- | --- |
    | 101 | 자바 | 김싸피 |
    | 102 | 자바 | 박디비 |
    | 103 | C | 가나다 |
    | 104 | 자바 | 김싸피 |
    
    <image src="./img/db_erd_and_normalization_21.png" width = "200px" height="150px" alt = "normalization img" >
    
    - (학생 번호, 과목)이 기본키로 지도교수를 알 수 있다.
    - 하지만 같은 과목을 다른 교수가 가르칠 수도 있어서 과목→지도교수 종속은 성립하지 않는다.
    - 지도교수가 어떤 과목을 가르치는지는 알 수 있다.
    - 즉, 지도교수→과목 종속은 성립한다.
    - 후보키 집합이 아닌 칼럼이 결정자가 되어버린 상황을 BCNF를 만족하지 않는다고 한다.
    - (위 예시는 제3 정규형까지는 만족하는 테이블이다)
    - 아래와 같이 분해한다.

    | 학생번호 | 지도교수 |
    | --- | --- |
    | 101 | 김싸피 |
    | 102 | 박디비 |
    | 103 | 가나다 |
    | 104 | 김싸피 |

    | 지도교수 | 과목 |
    | --- | --- |
    | 김싸피 | 자바 |
    | 박디비 | 자바 |
    | 가나다 | C |
    | 김싸피 | 자바 |
    - 참고로 위에서 학생 번호와 지도교수는 다치 종속성이 발생하게 되는데, 이는 제4 정규형에서 다뤄진다.

5. 제4 정규형 이상
    - 보통 정규화는 BCNF 까지만 하는 경우가 많다. 그 이상 정규화를 하면 정규화의 단점이 나타날 수도 있다. 4 정규형 이상은 아래 링크 참고
    
    [[DB] 제 4정규형과 제 5정규형, 4NF와 5NF](https://code-lab1.tistory.com/270)
    

## 5️⃣ 역정규화

역정규화는 데이터베이스의 비용을 최소화하기 위해 중복을 허용하며,

entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 db 구조를 재조정하는 과정

---

# 면접대비

- **정규화와 역 정규화에 대해 설명해보시오.**
    
    정규화는 무결성을 유지하기 위해 데이터를 구조화하는 작업입니다.
    
    정규화의 장점은 데이터베이스 변경 시 이상 현상을 제거하고,
    
    데이터베이스 구조 확장 시 재디자인을 최소화한다는 점입니다.
    
    단점은 릴레이션 분해로 인해서 릴레이션 간의 연산을 수행할 때
    
    join 이 많아지고 이로 인해 성능이 저하될 수 있습니다.
    
    <추가 설명>
    
    정규화에는 대표적으로 1 정규화, 2 정규화, 3 정규화가 존재합니다.
    
    **제1 정규화**
    
    - 릴레이션(테이블)의 튜플(행)은 반드시 고유해야 합니다.
    - 모든 특성들은 더 이상 분해할 수 없는 원자적이어야 합니다.
    - 쉽게 생각하면 기본키의 특성을 갖는 속성이 있어야 합니다.
    
    **제2 정규화**
    
    - 데이터는 반드시 1 정규화를 충족해야 한다.
    - 기본키가 아닌 속성들이 모두 기본키에 완전 함수 종속되어야 합니다
    
    **제3 정규화**
    
    - 데이터는 반드시 2 정규화를 충족해야 합니다.
    - 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않아야 합니다.
    
    역정규화는 데이터베이스의 비용을 최소화하기 위해 중복을 허용하며
    
    entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 db 구조를 재조정하는 과정입니다.
    
    정규화를 통해 분할된 entity로 인해 어떠한 로직을 위해 사용된 쿼리의
    
    join이 너무 많을 경우에 성능 저하가 발생할 수 있으므로
    
    이럴 때 역 정규화를 통하여 db의 전반적인 성능을 향상할 수 있는 구조화 과정을 거치는 것입니다.
    
- **ERD란?**
    
    개체-관계 다이어그램으로서 현실에 존재하는 사물이나 개체들을
    
    데이터로 변환시켜 해당 개체의 속성과 다른 개체와의 관계를 도식화하여 나타내 주는 다이어그램입니다.
    
    erd 다이어그램을 통해 개체의 성질과 데이터의 흐름을 파악하기가 용이해집니다.
    
- **Primary key에 대해서 말해보세요**
    
    후보키 중 선택한 메인 키로써, 각 row(record)를 unique하게 구분하는 column입니다.
    
    그렇기 때문에 null 값을 가질 수 없으며, 중복된 값을 가질 수 없습니다. table당 1개만 지정해야 합니다.
    
- **관계형 데이터베이스의 N:M 관계에 대해서 설명해주세요**
    
    RDB에서 양쪽 entity 모두 서로가 1:N 관계를 가지고 있는 구조입니다.
    
    예를 들면 학생 entity와 과목 entity가 있을 때, N:M 관계를 가집니다.
    
    특정 학생은 여러 과목을 선택할 수 있으며, 특정 과목 또한 여러 학생들에게 선택될 수 있습니다.

<br>

---

### 출처

[ERD와 정규화 과정](https://velog.io/@astrataraxia/ERD와-정규화-과정)


[[DB] 정규화(Normalization)란? 정규화 예시, 1NF, 2NF, 3NF, BCNF](https://code-lab1.tistory.com/48)

---